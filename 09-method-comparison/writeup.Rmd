---
title: "09-method-comparison"
author: Yasi Wang
date: 10/30/2019
output: 
  html_notebook: 
    highlight: tango
    theme: cosmo
---

Last time, we've discussed about confidence interval (CI) and coverage probability. This time, we will do more simulations with different estimations and caculate their corresponding coverage probabilities.

# Introduction
***

## Method of Moment estimation


## Kernal Density estimation

## Bootstrap estimation

```{r include=FALSE}
library(tidyverse)
```


```{r}
generate_data <- function(N, dist, sh, sc) {
  if(dist == "norm") {
    return(rnorm(N) + 4)
  } else if(dist == "gamma") {
    return(rgamma(N, shape = sh, scale = sc))
  }
}
```


```{r}
estimate.ci <- function(data, mod, R = 10, par.int, smoo = 0.3) {
  N <- length(data)
  sum.measure <- get(par.int)

  # if (mod == "MMnorm") {
  #    mm.mean <- mean(data)
  #    mm.sd <- sd(data)
  #    samp.dist <- NA
  #    
  #    for (i in 1:R) {
  #     sim.data <- rnorm(length(data), mm.mean, mm.sd)
  #     if(par.int == "median") {
  #       samp.dist <- median(sim.data)
  #       } else if(par.int == "min") {
  #         samp.dist <- min(sim.data)
  #       }
  #    }

  if (mod=="MMnorm"){ # assume the data is normal
    mm.mean <- mean(data)
    mm.sd <- sd(data)
    sim.data <- rnorm(length(data),mm.mean,mm.sd)
    
    sim.data <- array(rnorm(N*R,mm.mean,mm.sd),dim=c(N,R))
    samp.dist <- apply(sim.data,2,sum.measure)

  } else if(mod == "MMgamma") {
    mm.shape <- mean(data)^2/var(data)
    mm.scale <- var(data)/mean(data)
    
    sim.data <- array(rgamma(length(data)*R, shape = mm.shape, scale = mm.scale), dim = c(N, R))
    samp.dist <- apply(sim.data, 2, FUN = sum.measure)
    
  } else if(mod == "KDE") { # Oct.9th slide
    ecdfstar <- function(t, data, smooth = smoo) {
      outer(t, data, function(a, b) {pnorm(a, b, smooth)}) %>% rowMeans
      }
    
    tbl <- data.frame(
      x = seq(min(data) - 2*sd(data), max(data) + 2*sd(data), by = 0.01)
    )
    tbl$p <- ecdfstar(tbl$x, data, smoo)
    tbl <- tbl[!duplicated(tbl$p),]
    
    qkde <- function(ps, tbl){
      rows <- cut(ps, tbl$p, labels = FALSE)
      tbl[rows, "x"]
      }
    
    U <- runif(N * R)
    sim.data <- array(qkde(U, tbl), dim = c(N, R))
    samp.dist <- apply(sim.data, 2, FUN = sum.measure)

  } else if(mod == "Boot") {
    sim.data <- array(sample(data, N * R, replace = TRUE), dim = c(N, R))
    samp.dist <- apply(sim.data, 2, FUN = sum.measure)
    
  }
  return(quantile(samp.dist, c(0.05, 0.95)))
}


capture_par <- function(ci, true.par) {
  1 * (ci[1] < true.par & true.par < ci[2])
}

```


```{r}
# One replicate

N <- 201
shape.set <- 1.4
scale.set <- 3

true.norm.med <- qnorm(0.5)
true.norm.min <- mean(apply(array(rnorm(N*10000), dim = c(N, 10000)), 2, min))

true.gamma.med <- qgamma(0.5, shape = shape.set, scale = scale.set) 
true.gamma.min <- mean(apply(array(rgamma(N*10000, shape = shape.set, scale = scale.set), dim = c(N, 10000)), 2, min))
  
dist1 <- "norm"
model1 <- "MMnorm"
par.int1 <- "median"

cover <- NA
for (sims in 1:100) {
  cover[sims] <- generate_data(N, dist1) %>% estimate.ci(mod = model1, par.int = par.int1, R = 1000) %>% capture_par(true.par = true.norm.med + 4)

}

mean(cover)
```




```{r}
simsettings <- expand.grid(dist = c("norm", "gamma"), model = c("MMnorm", "MMgamma", "KDE", "Boot"), par.int = c("median", "min"), cov.prob =NA, stringsAsFactors = FALSE, KEEP.OUT.ATTRS = FALSE)


for (k in 1:nrow(simsettings)){
  dist1 <- simsettings[k, 1]
  model1 <- simsettings[k, 2]
  par.int1 <- simsettings[k, 3]
  
  if (dist1 == "norm" & par.int1 == "median") {
    true.par1 = true.norm.med + 4
  } else if (dist1 == "gamma" & par.int1 == "median") {
    true.par1 = true.gamma.med
  } else if (dist1 == "norm" & par.int1 == "min") {
    true.par1 = true.norm.min + 4
  } else if (dist1 == "gamma" & par.int1 == "min") {
    true.par1 = true.gamma.min
  }
  cover <- NA
  
  for (sims in 1:100) {
    cover[sims] <- generate_data(N, dist1, sh = shape.set, sc = scale.set) %>% estimate.ci(mod = model1, par.int = par.int1, R = 1000) %>% capture_par(true.par = true.par1)
    simsettings[k ,4] <- mean(cover)

  }
}
```


```{r}
simsettings
```



## Method of moments with 


# Conclusion

Method of moments often has best simulating accuracy than bootstrap if the distribution is assume is right. I think it is because method of moments is an estimation method with parameters. However, when the true distribution is gamma distribution, if fails to capture the minimum value of sample distribution.

Bootstrap estimates with more accuracy when the true distribution is standard norml, whereas its coverage probability becomes really low when the true distribution is gamm distribution.

Compared two parameters, it's much more easier for estimation method to cathch median value of true distribution than minimum value of each sample in standard normal distribution. It could be related my old blogs, which reveals the median value of samples from normal distribution is much less volatile than other values. Therefore, the coverage probability is high.

As I finally successed in using kernal density estimation to simulate distribution, I don't think it is a good way to estimate coverage probability. As it is aimed to plot a smooth graph of sample distribution and it is a method of non-parametric estimation. The result is the same as I expected, kernal density estimation has relatively low accuracy in gamma distribution. It performs only good when estimating standard normal distribution.
